<div class="card">
  <div class="card-body">
    <h4 class="card-title">Union Find</h4><hr />
    <h6>考え方</h6>
    <p>
      Union Findはある要素とある要素が同じグループに属するかどうかを判定するような問題で使用できる木構造です.
    </p>
    <p>
      普通のリストやセットでグループを管理すると, 同じグループかを判定するには, リストやセット内のすべての要素を探索して判定する, というような非常に非効率なものになります.
      なので, 「各グループで代表者を立てて, 所属しているグループの代表者が同じなら同グループに属する」というような判定方法を考えます.
    </p>
    <img src="/img/group.png" class="m-2">
    <p>
      例えばこのような5つの要素について3つのグループがある時, 一つ目のグループではAを代表にしてみると, BとCが同じグループに属しているかは, BとCそれぞれの属するグループの代表者がAであれば同じグループであるとわかります.
    </p>
    <p>
      これを木構造を用いてコンピュータが処理しやすいようなデータ構造で考えてこんな形に変換してみます.
    </p>
    <img src="/img/group_tree.png" class="m-2">
    <p>
      このようにすると, 木の根ノードが代表者, 同じ木に属しているノードは同じグループに属している要素となります.
      こうすることで「根ノードが同じなら同じグループに属する」という判定が出来るようになります.
    </p>
    <p>
      Union Findは, この木構造を併合したり, 組み替えたりして, 効率的にグループ判定の出来るデータ構造となります.
    </p>
    <hr />
    <h6>実装</h6>
    <p>
      必要になるのは「木の併合」と「根ノードの探索」の2つです.
      実装すると以下のような形になります.
    </p>
    <pre><code class="language-cpp">
      int par[MAX_N], rank[MAX_N];

      /* 初期化 */
      void init(int n){
        for(int i=0;i&gt;n;i++){
          par[i]=i;
          rank[i]=0;
        }
      }

      /* 根ノード探索 */
      int find(int x){
        if(par[x] == x) return x;
        else{
          /* path compression */
          par[x] = find[x];
          return par[x];
        }
      }

      /* 併合 */
      void union(int x, int y){
        int px = find(x), py = find(y);
        if(px == py) return;
        /* union by rank */
        if(rank[px] &gt; rank[py]) par[px] = py;
        else par[py] = px;
        if(rank[px] == rank[py]) rank[x]++;
      }
    </code></pre>
    <p>
      初期化はすべて自分が自分の親となるようにして, 自分の親が自分であれば, そのノードは根ノードであるとみなします.
      こうすることで根ノード探索は<code class="language-cpp">par[x] == x</code>となるまで再帰するだけでよくなり, 
      また併合も根ノードの親を相手に設定すれば終了です.
    </p>
    <p>
      上のコードでは, Union Findの2つの工夫を取り入れています.
      1つはunion by rank, もう1つはpath compressionです.
    </p>
    <hr />
    <h6>union by rank</h6>
    <p>
      union by rankは木を併合する際に「木の大きい方に木の小さい方を併合する」というものです.
      なお木の大きさは高さで表し, その木の高さをランクと呼びます.
      これをすると何が嬉しいかというと, 併合後に木の偏りが出にくくなるので, 無駄に高い木を作らなくて済むようになり, 根ノードまでの探索時間が短縮されます.
    </p>
    <p>
      例えば, このような2つの木を併合するときに, ランクの低い方にランクの高い木を併合すると, 併合後の木のランクは[高い方のランク+1]になります.
    </p>
    <img src="/img/badunion.png" class="m-2">
    <p>
      しかし, ランクの高い方にランクの低い方を併合すると, 高さが増えず, ランクも増えません.
    </p>
    <img src="/img/goodunion.png" class="m-2">
    <p>
      このように併合していくことで高さをなるべく増やさないように併合できます.
      ここでランクが同じ木を併合する場合にだけは, どうしてもランクが1上昇するため, 忘れぬよう注意です.
    </p>
    <hr />
    <h6>path compression</h6>
    <p>
      path compressionは, 木を根ノードまで探索する際, 通ったすべてのノードの親を根ノードにする, というものです.
      単純明快で一度通ったノードに関しては根ノードにダイレクト接続することになるので, 根ノードまでの探索が爆速になります.
    </p>
    <p>
      例えば, この木はFとEからそれぞれ探索をすると, こうなります.
    </p>
    <img src="/img/pathcompression.png" class="m-2">
    <hr />
    <h5>まとめ</h5>
    <p>
      Union Findはグループを効率的に管理出来る木構造!!
    </p>
    <p>
      ランクの高い方に併合!!
    </p>
    <p>
      パスは縮約!!
    </p>
    <p>
      以上になります~~
    </p>
    <p>
      間違い等ありましたら
      <a href="https://twitter.com/kilattoeruru">えるる</a>
      までリプライでも飛ばしてください~
    </p>
    </div>
</div>
