<div class="card">
  <div class="card-body">
    <h4 class="card-title">Union Find</h4><hr />
    <h6>考え方</h6>
    <p>
      Union Findはある要素とある要素が同じグループに属するかどうかを判定するような問題で使用できる木構造です.
    </p>
    <p>
      普通のリストやセットでグループを管理すると, 同じグループかを判定するには, リストやセット内のすべての要素を探索して判定する, というような非常に非効率なものになります.
      なので, 「各グループで代表者を立てて, 所属しているグループの代表者が同じなら同グループに属する」というような判定方法を考えます.
    </p>
    <img src="/img/group.png">
    <p>
      例えばこのような5つの要素について3つのグループがある時, 一つ目のグループではAを代表にしてみると, BとCが同じグループに属しているかは, BとCそれぞれの属するグループの代表者がAであれば同じグループであるとわかります.
    </p>
    <p>
      これを木構造を用いてコンピュータが処理しやすいようなデータ構造で考えてこんな形に変換してみます.
    </p>
    <img src="/img/group_tree.png">
    <p>
      このようにすると, 木の根ノードが代表者, 同じ木に属しているノードは同じグループに属している要素となります.
      こうすることで「根ノードが同じなら同じグループに属する」という判定が出来るようになります.
    </p>
    <p>
      Union Findは, この木構造を併合したり, 組み替えたりして, 効率的にグループ判定の出来るデータ構造となります.
    </p>
    <hr />
    <h6>実装</h6>
    <p>
      必要になるのは「木の併合」と「根ノードの探索」の2つです.
      実装すると以下のような形になります.
    </p>
    <pre><code class="language-cpp">
      int par[MAX_N], rank[MAX_N];

      /* 初期化 */
      void init(int n){
        for(int i=0;i&gt;n;i++){
          par[i]=i;
          rank[i]=0;
        }
      }

      /* 根ノード探索 */
      int find(int x){
        if(par[x] == x) return x;
        else{
          par[x] = find[x]
          return par[x];
        }
      }

      /* 併合 */
      void unite(int x, int y){
        int px = find(x), py = find(y);
        if(px == py) return;
        if(rank[px] &gt; rank[py]) par[px] = py;
        else
      }
    </code></pre>
    <p>
      初期化はすべて自分が自分の親となるようにして, 自分の親が自分であれば, そのノードは根ノードであるとみなします.
      こうすることで根ノード探索は<pre class="language-cpp">par[x] == x</pre>となるまで再帰するだけでよくなり, 
      また併合も根ノードの親を相手に設定すれば終了です.
    </p>
  </div>
</div>
