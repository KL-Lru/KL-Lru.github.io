<div class="card">
  <div class="card-body">
    <h4 class="card-title">モジュラ逆数</h4><hr />
    <h6>考え方</h6>
    <p>
      競技プログラミングでよく見る「 $10^9 + 7$ で割った余りを出力せよ」っていう問題で使うものです. 
      往々にして, 計算結果が爆発する組み合わせの問題なんかに出てきます. 
    </p>
    <p>
      出力を $X$ で割った余りとするときには, 計算過程を全て $X$ を法とする剰余類環の中で行っても構わないことになります. 
      $X$を法とする剰余類環は「整数をそれぞれ $X$ で割った余りに対応させた世界」と考えるとわかりやすいと思います. 
      例えば「$(a + b) × c$ の値を$5$で割った余りを出力せよ」なんていう問題のとき, $a = 3$, $b = 4$, $c = 8$であれば, 
    </p>
    <p>
      普通に計算すると,
      $$(3 + 4) × 8 = 7 × 8 = 56 \equiv 1 ~({\rm mod} ~5)$$
    </p>
    <p>
      計算過程も含めて5を法とする剰余類環の中で行うと,
      $$(3 + 4) × 3 \equiv 2 × 3 \equiv 6 \equiv 1 ~({\rm mod} ~5)$$
    </p>
    <p>
      と一致します. 
      こうすることで計算過程で64bit 整数の表現可能範囲を超えてしまったりする場合にも正しく計算することが出来ます. 
      ただ割り算については, 足し算や掛け算のように通常の計算と同様に行うことが出来ないので「掛け算に変換する」という処理をします.
    </p>
    <p>
      「$a$で割る」ということは「$a$の逆数を掛ける」ということに等しくなります. 
      通常で考えれば, $a$の逆数は「$\frac{1}{a}$」になりますが, $X$ を法とする剰余類環には, 「$\frac{1}{a}$」が存在するとは限りません. (というか a = 1 の時しか存在しません) 
    </p>
    <p>
      ところで「$a$の逆数」とは? というと, $a × a^{-1} = 1$ となるような $a^{-1}$ が $a$ の逆数になります. 
      これであれば, $X$ を法とする剰余類環にもある条件を満たしていて, $a = 0$でなければ, 存在します. 
    </p>
    <p>
      例えば上の計算を見てみると, $5$ を法とする剰余類環の中では,
      $$ 2 × 3 \equiv 1 ~({\rm mod} ~5) $$
      であるので $2$ の逆数は $3$ であり, $3$ の逆数は $2$ であるということが分かります. 
      つまり, 「$2$ で割る」ということは「$3$ を掛ける」ということに等しくなります. 
    </p>
    <p>
      この $X$ を法とする剰余類環に存在する $a$ の逆数, 「モジュラ逆数」が求められれば, 全ての計算が $X$ を法とする剰余類環の中で, 行えることになります.
      このモジュラ逆数の求め方をどうにかしよう〜というのがこのページです.
    </p><hr />
    <h6>フェルマーの小定理</h6>
    まずはフェルマーの小定理がどんなものなのかちゃちゃっと見ましょう.
    <div class="card m-1">
      <div class="card-body">
        <h5 class="card-title">フェルマーの小定理</h5><hr />
        $p$ を素数とし, $a$ を $p$ の倍数でない整数とするとき
        $$a^{p-1} \equiv 1 ~({\rm mod} ~p)$$
      </div>
    </div>
    <p>
      証明はどうしようか迷いましたが, 折りたたんで置くので読みたい人は読んでって感じです.
      <p>
        <button type="button" class="btn btn-raised btn-info" data-toggle="collapse" data-target="#proof0">証明</button>
      </p>
      <div id="proof0" class="collapse">
        <div class="card m-1">
          <div class="card-body">
            <h5 class="card-title">フェルマーの小定理証明</h5><hr />
            $a$と$p$は互いに素であるため, $a, 2a, ..., (p-1)a$は全て$p$の倍数ではなく, それぞれ$p$による剰余は相異なる.
            よって
            $$a \times 2a \times ... \times (p-1)a \equiv (p-1)! ~({\rm mod} ~p)$$
            よって, 両辺を$(p-1)!$で割って
            $$a^{p-1} \equiv 1 ~({\rm mod} ~p)$$
          </div>
        </div>
      </div>
      この定理を使うと, 法とする数が素数であれば, 簡単にそのモジュラ逆数を求めることが出来ます. 
      要は, モジュラ逆数は $a^{-1}$ なのでこれをフェルマーの小定理の両辺に掛けると
      $$ a^{p-2} \equiv a^{-1} ~({\rm mod} ~p) $$
      これでモジュラ逆数が求まります. 
      とても簡単!
    </p>
    <hr />
    <h6>実装例</h6>
    <pre><code class="language-cpp">
      #define ll long long
      ll mod_inverse(ll a, ll p){
        ll x = 1, n = p - 2;
        while(n != 0){
          if(n%2 == 1){ 
            x = (x * a) % p;
            n -= 1;
          }else{
            x = (x * x) % p;
            n /= 2;
          }        
        }
        return x;
      }
    </code></pre>
    <p>
      愚直に実装すると$p-2$回の乗算が発生します. 
      $p = 10^9+7$とかの時には計算量酷くて爆発するので, 累乗計算は工夫しましょうというやつです. 
      指数が奇数なら$a$を一回掛けて指数を1減らし, 指数が偶数なら$a$を二乗して指数を半分にする, というだけでとても簡単に計算量をかなり削減できます. 
      O(log2(n))です.
    </p>
    <p>
      例えば, $p = 17$であれば, 
      $$a^{p - 2} = a^{15} = ((a^2 \times a)^2 \times a)^2 \times a $$
      のように計算がわけられることを使っています.
    </p>
    <hr />
    <h6>拡張ユークリッド互除法</h6>
    <p>
      みなさん大好きのユークリッドの互除法, それを拡張して$ax + by = c$形式で$a, b, c$がわかっている時に($c$に制約がありますけど)$x, y$を求めちゃおうというアルゴリズムです.
      これを応用することで高速にモジュラ逆数を計算することが出来ます.
      まずユークリッドの互除法はこちら
    </p>
    <div class="card m-1">
      <div class="card-body">
        <h5 class="card-title">ユークリッドの互除法</h5><hr />
        2つの自然数$a,b(a \geq b)$について, $a$を$b$で割った剰余を$r$とし, $a,b$の最大公約数を${\rm gcd}(a,b)$とする.
        このとき, ${\rm gcd}(a,b) = {\rm gcd}(b,r)$であり, ${\rm gcd}(a,0) = a$である.
        ${\rm gcd}(a,b)$はその2つの自然数の大きい方を小さい方で割り, その除数と剰余について同様の操作を繰り返していくことで求められる.
      </div>
    </div>
    <p>
      証明は折りたたみー.
      <p>
        <button type="button" class="btn btn-raised btn-info" data-toggle="collapse" data-target="#proof1">証明</button>
      </p>
      <div id="proof1" class="collapse">
        <div class="card m-1">
          <div class="card-body">
            <h5 class="card-title">ユークリッドの互除法の証明</h5><hr />
            上に加えて$a$を$b$で割った商を$q$とすると, 
            $$a = qb + r $$
            となる.
            この時, ${\rm gcd}(a,b)$は$a$と$b$をどちらも割り切ることが出来るので$a - qb$も, つまりは$r$を割り切ることが出来る.
            逆も同様に${\rm gcd}(b,r)$は$b$と$r$をどちらも割り切ることが出来るので$qb + r$も, つまりは$a$を割り切ることが出来る.
            つまり, $a$と$b$の公約数全体の集合は$b$と$r$の公約数全体の集合と等しくなる. 
            そして終了条件は剰余が0となった時, つまりは公約数で割ってしまった場合である.
            さらにこの手続きは$a,b$共に単調減少になるので, 見つかる数は$a, b$の公約数全体の中で最大のもの, つまりは最大公約数になる.
          </div>
        </div>
      </div>
    </p>
    <p>
      プログラムで書くとわかりやすい.
      <pre><code class="language-cpp">
          int gcd(int a, int b){
            if(b == 0) return a;
            else return gcd(b, a%b);
          }
        </code></pre>
    </p>
    <p>
      そしてここからが拡張ユークリッドの互除法です. 
    </p>
    <div class="card m-1">
      <div class="card-body">
        <h4 class="card-title">拡張ユークリッドの互除法</h4><hr />
        2つの自然数$a,b(a \geq b)$について, $a,b$の最大公約数を${\rm gcd}(a,b)$とする.
        このとき, 任意の整数$c$について$ax + by = c ~{\rm gcd}(a,b)$を満たす整数解$x,y$が存在し, 
        ユークリッドの互除法を応用することによって求めることが出来る.
      </div>
    </div>
    <p>
      $ax + by = c$が整数解を持つことの必要十分条件は, $c$が${\rm gcd}(a,b)$の倍数になることです.
      例によって証明は折りたたみ.
      <p>
        <button type="button" class="btn btn-raised btn-info" data-toggle="collapse" data-target="#proof2">証明</button>
      </p>
      <div id="proof2" class="collapse">
        <div class="card m-1">
          <div class="card-body">
            <h5 class="card-title">拡張ユークリッドの互除法に必要な証明</h5><hr />
            <h6>$ax + by = c$が整数解を持つ $\Rightarrow$ $c$が${\rm gcd}(a,b)$の倍数になる.</h6>
            <p>
              $a,b$は${\rm gcd}(a,b)$の倍数である.
              よって, 整数$x,y$について$ax + by$は${\rm gcd}(a,b)$の倍数であり, すなわち$c$は${\rm gcd}(a,b)$の倍数である.
            </p>
            <hr />
            <h6>$ax + by = c$が整数解を持つ $\Leftarrow$ $c$が${\rm gcd}(a,b)$の倍数になる.</h6>
            <p>
              $s, t$を, $a,b$をそれぞれ${\rm gcd}(a,b)$で割った数とする.
              この時,  $s,t$は互いに素となる.
              ここで, $ax + by = 1$が整数解を持つことの必要十分条件が, $a$と$b$が互いに素であることを証明する.
            </p>
            <div class="card m-1">
              <div class="card-body">
                <h5 class="card-title">補題証明</h5><hr />
                <h6>$ax + by = 1$が整数解を持つ $\Rightarrow$ $a$と$b$が互いに素である</h6>
                <p>
                  $a$と$b$が2以上の公約数を持つと仮定すると, $ax+by$は整数解を持つことが出来ないため矛盾が生じる.
                  よって$a$と$b$は互いに素である
                </p>
                <hr />
                <h6>$ax + by = 1$が整数解を持つ $\Leftarrow$ $a$と$b$が互いに素である</h6>
                <p>
                  $a$と$b$は互いに素であるため, $a, 2a, ..., (b-1)a$は全て$b$の倍数ではなく, $b$による剰余は相異なる.
                  すなわち, ある整数$n$が存在して, $an \equiv 1 ({\rm mod} ~b)$となるため, 
                  これに対しある整数$m$が存在して $an = bm + 1$, すなわち$an - bm = 1$となる.
                  よって$ax + by = 1$が整数解$(n, -m)$を持つ.
                  ($a$と$b$が互いに素であるため, $a$の倍数全体の集合について, $b$を法として合同となる数を同一視する, という同値関係で作られる剰余類は,
                  その全体が$b$を法とする既約剰余類群となる.とかでも証明出来ますが, 書いてても理解的にも上の方が簡単だと思います.)
                </p>
              </div>
            </div>
            <p>
              以上から$ax + by = 1$が整数解を持つことの必要十分条件は, $a$と$b$が互いに素であることである.
              よって$s,t$は互いに素であるため, $sx + ty = 1$は整数解を持つ.
              よって, 両辺に${\rm gcd}(a,b)$を掛けると$ax + by = {\rm gcd}(a,b)$であり, $ax + by = c$が整数解を持つことが示された.
            </p>
          </div>
        </div>
      </div>
    </p>    
    <p>
      軽くアルゴリズムを説明すると, 剰余だけでなく, ユークリッドの互除法を適用する過程で出てくる商や被除数, 除数も記録しておき, 最大公約数が出たところから逆にたどっていく, というものになります.
      例えば$17x + 7y = 1$を解いて見ます.
    </p>
    <p>
      \begin{eqnarray}
      17 \div 7 & = & 2 ... 3 \rightarrow 3 = 17 - 2 \times 7 \\
      7 \div 3 & = & 2 ... 1 \rightarrow 1 = 7 - 2 \times 3 \\
      3 \div 1 & = & 3 ... 0 \rightarrow {\rm gcd} = 1
      \end{eqnarray}
      これを逆にたどります.
      \begin{eqnarray}
      1 & = & 7 - 2 \times 3 \\
        & = & 7 - 2 \times (17 - 2 \times 7) \\
        & = & -2 \times 17 + 5 \times 7
      \end{eqnarray}
      はい, これで, $x = -2, y = 5$が導き出せました.
    </p>
    <p>
      一般的に書くとすると, 2つの自然数$a,b$に対して, $a$を$b$で割った商を$q$, 剰余を$r$として, 
      $ax + by = {\rm gcd}(a,b)$を解くべき方程式とすると, 
      $a = qb +r$なので, 次のステップでは$(qb + r)x + by = {\rm gcd}(a,b)$,すなわち $b(qx + y) + rx = {\rm gcd}(a,b)$になります.
      逆に今のステップの$ax' + by' ={\rm gcd}(a,b)$が解け, 解$(x', y')$が得られたとすると, 
      前のステップの解は$x = y', y = x' - qy'$となる.
      また, 問題が解けるのは, ${\rm gcd}(a,b)x + 0y ={\rm gcd}(a,b)$となる時であり, 明らかに$(1,0)$が解となる.
      というような形で問題を解くことが出来ます.
    </p>
    <p>
      なお, このアルゴリズムを用いたモジュラ逆数の求め方は簡単で, $a$に求めたい数を, $b$に基数を入れて動かせば, $x$にモジュラ逆数が出てきてくれます.
      このとき, $a$と$b$は互いに素でなくてはならないのを忘れてはならないですが, 競プロでよく目にする$10^9+7$は素数なので$10^9+7$を法とした剰余類環の中で計算する分には
      問題は起きません.
    </p>
    <hr />
    <h6>実装例</h6>
    <pre><code class="language-cpp">
      #define ll long long
      #define MOD 1e+9
      ll ext_gcd(ll a, ll b, ll& x, ll& y){
        ll gcd = a;
        if(b != 0){
          gcd = ext_gcd(b, a % b, y, x);
          y = (y - (a / b) * x) % MOD; // モジュラ逆数じゃなくて方程式計算の時は%MODは不要
        } else {
          x = 1;
          y = 0;
        }
        return gcd;
      }
      /* xの計算結果は負になることもあるので, モジュラ逆数として使うときは正にする */
      ll posi_modular_inverse(ll a, ll b, ll& x, ll& y){
        ll gcd = ext_gcd(a, b, x, y);
        x = (x + MOD) % MOD;
        return gcd;
      }
    </code></pre>
    <p>
      $x, y$は再帰最深部で初期化されるので, 変数宣言だけしてあれば正常に使えます.
      途中に$x$と$y$が度々入れ替わるのでめんどくさいです.
      多分忘れて1から書いたらバグを有むエリアだと思います.
      ちなみに$10^9+7$で割った余りを求める問題なら, long longの壁を超えることはないです.
      計算量はO(log(n))です.
    </p>
    <hr />
    <h6>まとめ</h6>
    <p>
      モジュラ逆数は割り算を掛け算に出来る便利な奴!!
    </p>
    <p>
      フェルマーの小定理はさくっと書ける!!
    </p>
    <p>
      拡張ユークリッドはめんどくさい!!!!
    </p>
    <p>
      間違い等ありましたら
      <a href="https://twitter.com/kilattoeruru">えるる</a>
      までリプライでも飛ばしてください~
    </p>

  </div>
</div>
