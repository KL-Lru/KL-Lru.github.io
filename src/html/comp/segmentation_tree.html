<div class="card">
  <div class="card-body">
    <h1 class="card-title title">セグメント木</h1>
    <h2 class="part">考え方</h2>
    <p>
      セグメント木はある区間への操作を効率的に行えるように完全二分木を利用するデータ構造となっています. 
    </p>
    <p>
      例えば「ここからここまでの区間内の最小値を求めろ」というクエリを多量に実行するタスク, 通称RMQ行う際, 普通のリストで行うとなると, 指定の範囲を毎回走破させなければならず, リストの大きさをN, クエリの数をMとすると, 最悪の場合O(N*M)となり, 計算量が爆発します. 
    </p>
    <p>
      これを完全二分木によって計算量を抑えます.
      完全二分木とは以下のような一つの節ノードに対して, 必ず二つの子ノードが接続されていて, 全ての葉の深さが等しいような木のことを言います.
    </p>
    <img src="/img/binarytree.png" class="m-2">
    <p>
      どのように利用するかというと, 完全二分木の葉ノードについて, インデックスを振り, 葉ノードをリストと見立てて考えます. 
      そしてその親ノードを子ノード二つをカバーする範囲の情報を持つものとして木を構築します.
    </p>
    <p>
      葉ノードにリストとしてのインデックスを振ると, 各ノードが保持する情報の範囲は次のようになります.
    </p>
    <img src="/img/segmentationtree.png" class="m-2">
    <p>
      例えばRMQであれば以下のように, 各節ノードが子ノードのうち小さいものの値を保持するように木を構築します.
    </p>
    <img src="/img/rmqsegmentationtree.png" class="m-2">
    <p>
      このようにデータを保持することで, 一定の範囲について再度計算する必要がなくなるため, 計算量を削減されます. 
      例えば上の木で閉区間[1,7]の範囲での最小値を求めようとすると, 次のノードだけを参照すればよいこととなり, 普通のリストでは7回比較する必要があるところを3回で済ませることが出来るようになります.
    </p>
    <img src="/img/segmentationtreequery.png" class="m-2">
    <p>
      計算量としてはO(logN)で一つのクエリを計算できるため, クエリ数Mなら計算量はO(M*logN)になります.
    </p>

    <h2 class="part">実装</h2>
    <p>
      必要となるのは「初期化」と「更新」と「クエリ処理」です.
      RMQについて実装すると以下のようになります.
    </p>
    <pre class="line-numbers" data-src="/src/cpp/segTree.cpp"></pre>
    <p>
      セグメント木は一次元の配列で表現出来ます. 
      配列の各インデックスは次の図のようになります.
    </p>
    <img src="/img/segmentationtreeindex.png" class="m-2">
    <p>
      常套手段という感じではありますが, 配列中のインデックスxである子ノードのインデックスが2x+1と2x+2であり, 親ノードのインデックスが(x-1)/2となるように木を構築するといい感じにデータを保持できます.
    </p>
    <p>
      葉のノード数をNとすると, 完全二分木では葉以外のノード数はN-1になります. 
      葉ノードに元のリストの値を格納していくので, 元のリストはインデックスN-1以降に入っていくことになるため, 値の更新時にはリストのインデックスにN-1を足したインデックスから木を辿り更新を行います.
    </p>
    <p>
      クエリ処理時はセグメント木を上から見ていき, 見ているノードが担当している範囲が, クエリの範囲内にあった場合にはノードの値を返し, 全く範囲が重なっていない場合にはINF値を返し, 部分的に重なっている場合には下のノードへと辿って行き再帰します.
    </p>

    <h2 class="part">まとめ</h2>
    <p>
      セグメント木は区間に強いデータ構造!!
    </p>
    <p>
      セグメント木は配列で!!
    </p>
    <p>
      以上になります~~
    </p>
    <p>
      間違い等ありましたら
      <a href="https://twitter.com/kilattoeruru">えるる</a>
      までリプライでも飛ばしてください~
    </p>
  </div>
</div>